import { db } from './db'; // Mock DB client
import { hasUnitAccess } from '../middleware/auth';
import { ApiError } from '../utils/errors';

// Type definitions (ideally from a central types file or generated by Prisma)
interface Shift {
  id: string;
  userId: string;
  unitId: string;
  start: Date;
  end: Date | null;
  [key: string]: any;
}

type ShiftCreateData = Omit<Shift, 'id'>;
type ShiftUpdateData = Partial<ShiftCreateData>;


/**
 * Checks if a new or updated shift overlaps with existing shifts for the same user.
 * @param userId The ID of the user.
 * @param start The start time of the new shift.
 * @param end The end time of the new shift.
 * @param excludeShiftId An optional shift ID to exclude from the check (used when updating a shift).
 */
async function checkForOverlappingShifts(userId: string, start: Date, end: Date | null, excludeShiftId?: string) {
  if (!end) return; // Open-ended shifts can't be checked for overlap in this simple model

  const existingShifts = await db.shift.findMany({
    where: {
      userId,
      id: { not: excludeShiftId },
      // Check for shifts that start before the new one ends AND end after the new one starts
      start: { lt: end },
      end: { gt: start },
    },
  });

  if (existingShifts.length > 0) {
    throw new ApiError(409, 'Conflict: The proposed shift overlaps with an existing shift.');
  }
}

/**
 * Creates a new shift after performing validation and authorization checks.
 * @param data - The validated data for the new shift.
 * @param currentUser - The user performing the action.
 */
export async function createShift(data: ShiftCreateData, currentUser: Express.Request['user']): Promise<Shift> {
  // 1. Authorization Check: Ensure user has access to the target unit
  if (!hasUnitAccess(currentUser, data.unitId)) {
    throw new ApiError(403, 'Forbidden: You do not have permission to create shifts for this unit.');
  }

  const start = new Date(data.start);
  const end = data.end ? new Date(data.end) : null;

  // 2. Data Consistency Check: Prevent overlapping shifts
  await checkForOverlappingShifts(data.userId, start, end);
  
  // 3. Create the shift in the database
  const newShift = await db.shift.create({
    data: { ...data, start, end },
  });

  return newShift;
}

/**
 * Updates an existing shift.
 * @param shiftId The ID of the shift to update.
 * @param data The validated update data.
 * @param currentUser The user performing the action.
 */
export async function updateShift(shiftId: string, data: ShiftUpdateData, currentUser: Express.Request['user']): Promise<Shift> {
  // 1. Find the existing shift
  const existingShift = await db.shift.findUnique({ where: { id: shiftId } });
  if (!existingShift) {
    throw new ApiError(404, 'Shift not found.');
  }

  // 2. Authorization Check: User must have access to the shift's unit
  if (!hasUnitAccess(currentUser, existingShift.unitId)) {
    throw new ApiError(403, 'Forbidden: You do not have permission to modify this shift.');
  }

  const newStart = data.start ? new Date(data.start) : existingShift.start;
  const newEnd = data.end ? new Date(data.end) : existingShift.end;

  // 3. Data Consistency Check: Prevent overlaps if times are changing
  if (data.start || data.end) {
    await checkForOverlappingShifts(existingShift.userId, newStart, newEnd, shiftId);
  }

  // 4. Update the shift
  const updatedShift = await db.shift.update({
    where: { id: shiftId },
    data: { ...data, start: newStart, end: newEnd },
  });

  return updatedShift;
}
